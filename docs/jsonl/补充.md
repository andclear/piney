# 补充：处理“非代码块内的 HTML/CSS/JS”与多片段渲染（面向复刻）

本文是对 `酒馆助手渲染方法.md` 的补充，专门回答：

- AI 输出的内容经过 SillyTavern（markdown + sanitize + hooks + style 沙箱化）后，可能出现“HTML 标签直接出现在正文中、并
  不在代码块里”的情况，应该怎么处理。
- 典型失败用例：`<style>...</style><div>...</div>`（不在代码块），在你的其他项目里“style 没有作用到后续 div”，以及“一条
  消息里有多个结构片段”。

结论先行：

1. 这不是“插件渲染不完整”，而是“你把正文 HTML 片段搬运/拆分后，破坏了 SillyTavern 的作用域与前缀规则”。

2. SillyTavern 的 display 链路会把 `<style>` 做 **编码→sanitize→解码**，并对 CSS 选择器强制加前缀 `.mes_text `，同时
   DOMPurify hook 会把 HTML 里的 `class` 改成 `custom-xxx`。

3. 你若在其他项目里把这段 HTML 片段放进 iframe 或另一个容器，但没有带上 `.mes_text` 容器（或没有去掉 CSS 前缀），那 CSS
   当然不会匹配；如果你把 `<style>` 和 `<div>` 分别放到不同 iframe，更不会生效。

下面按“酒馆实际行为 → 失败原因 → 可复刻方案（含代码）”展开。

---

## 1. SillyTavern display 链路对“正文 HTML”到底做了什么

### 1.1 关键事实：最终写入 `.mes_text` 的是 `messageFormatting()` 的返回值

来自 SillyTavern（见你整理的 `我的回答.md`），`messageFormatting()` 最后一定会：

```js
const config = {
  RETURN_DOM: false,
  RETURN_DOM_FRAGMENT: false,
  RETURN_TRUSTED_TYPE: false,
  MESSAGE_SANITIZE: true,
  ADD_TAGS: ['custom-style'],
  ...sanitizerOverrides,
};
mes = encodeStyleTags(mes);
mes = DOMPurify.sanitize(mes, config);
mes = decodeStyleTags(mes, { prefix: '.mes_text ' });

return mes;
```

这意味着：

- 正文中即使包含 `<style>...</style>`，也不会“原样进入 DOM”。
- `<style>` 会被转换成 `<custom-style>` 先过 DOMPurify，再被解码回 `<style>`。

### 1.2 `<style>` 的编码（encodeStyleTags）

```js
export function encodeStyleTags(text) {
  const styleRegex = /<style>(.+?)<\/style>/gims;
  return text.replaceAll(styleRegex, (_, match) => {
    return `<custom-style>${encodeURIComponent(match)}</custom-style>`;
  });
}
```

含义：

- `<style>...</style>` 不会直接参与 DOMPurify 的标签/属性过滤。
- style 内容先 encodeURIComponent 进 `<custom-style>` 文本。

### 1.3 `<style>` 的解码与“沙箱化”（decodeStyleTags）

SillyTavern 解码时会：

1. 解析 CSS AST
2. 过滤 `@import`
3. 给每条 selector 加前缀（默认 `.mes_text `）
4. 给 selector 里的 class 加 `custom-` 前缀（与 DOMPurify hook 对 class 的处理保持一致）

关键片段（简化摘录，保持原逻辑）：

```js
export function decodeStyleTags(text, { prefix } = { prefix: '.mes_text ' }) {
  const styleDecodeRegex = /<custom-style>(.+?)<\/custom-style>/gms;
  const mediaAllowed = isExternalMediaAllowed();

  function sanitizeRule(rule) {
    if (Array.isArray(rule.selectors)) {
      for (let i = 0; i < rule.selectors.length; i++) {
        const selector = rule.selectors[i];
        if (selector) {
          rule.selectors[i] = prefix + sanitizeSelector(selector);
        }
      }
    }
    if (!mediaAllowed && Array.isArray(rule.declarations) && rule.declarations.length > 0) {
      rule.declarations = rule.declarations.filter(declaration => !declaration.value.includes('://'));
    }
  }

  function sanitizeSimpleSelector(selector) {
    return selector
      .split(/\s+/)
      .map(part => {
        return part.replace(/\.([\w-]+)/g, (match, className) => {
          if (className.startsWith('custom-')) {
            return match;
          }
          return `.custom-${className}`;
        });
      })
      .join(' ');
  }

  function sanitizeRuleSet(ruleSet) {
    if (Array.isArray(ruleSet.selectors) || Array.isArray(ruleSet.declarations)) {
      sanitizeRule(ruleSet);
    }
    if (Array.isArray(ruleSet.rules)) {
      ruleSet.rules = ruleSet.rules.filter(rule => rule.type !== 'import');
      for (const mediaRule of ruleSet.rules) {
        sanitizeRuleSet(mediaRule);
      }
    }
  }

  return text.replaceAll(styleDecodeRegex, (_, style) => {
    try {
      let styleCleaned = decodeURIComponent(style).replaceAll(/<br\/>/g, '');
      const ast = css.parse(styleCleaned);
      const sheet = ast?.stylesheet;
      if (sheet) {
        sanitizeRuleSet(ast.stylesheet);
      }
      return `<style>${css.stringify(ast)}</style>`;
    } catch (error) {
      return `CSS ERROR: ${error}`;
    }
  });
}
```

结论：SillyTavern 的 `<style>` 从来不是“全局 CSS”。它会被强制作用域到 `.mes_text` 下，并且会把 `.foo` 变成
`.custom-foo`。

### 1.4 DOMPurify hooks 对 class 的“custom- 前缀化”

SillyTavern 在 sanitize 阶段还会把元素 class 做改写：

```js
DOMPurify.addHook('uponSanitizeAttribute', (node, data, config) => {
  if (!config['MESSAGE_SANITIZE']) {
    return;
  }

  switch (data.attrName) {
    case 'class': {
      if (data.attrValue) {
        data.attrValue = data.attrValue
          .split(' ')
          .map(v => {
            if (v.startsWith('fa-') || v.startsWith('note-') || v === 'monospace') {
              return v;
            }
            return 'custom-' + v;
          })
          .join(' ');
      }
      break;
    }
  }
});
```

这解释了为什么在酒馆里“正文 `<style>.box{...}</style><div class="box">`”还能对上：

- DOM：`<div class="custom-box">...`
- CSS：`.mes_text .custom-box { ... }`

---

## 2. 为什么你在其他项目里 `<style></style><div></div>` 不生效

你描述的失败现象（style 不作用到后续 div、且一页多个结构）通常来自以下一种或多种原因：

### 2.1 你把 style 和 div 拆成了不同“渲染单元”（尤其是不同 iframe）

CSS 作用域永远不会跨 iframe。

如果你按“每个片段一个 iframe”来做：

- iframe A：只放 `<style>...`
- iframe B：只放 `<div>...`

那样 B 必然不会被 A 影响。

### 2.2 你搬运的是“已经被 SillyTavern 前缀化”的 CSS，但没有 `.mes_text` 容器

SillyTavern 解码 style 时默认 prefix 是 `.mes_text `。

如果你把这段 HTML（包含 `<style>.mes_text .custom-box{...}</style><div class="custom-box">...</div>`）塞进 iframe 的
`<body>`，但 iframe 内没有 `.mes_text` 容器，那么选择器 `.mes_text .custom-box` 不会匹配。

解决只有两种：

- 方案 A：在 iframe 内包一层 `<div class="mes_text">...</div>`（推荐，最等价）
- 方案 B：把 CSS 里的 `.mes_text ` 前缀剥离掉（不等价，且容易误伤复杂选择器）

### 2.3 你用的是“原始 class 名”，但 CSS / DOM 在酒馆里会被改成 `custom-xxx`

在酒馆 display 链路里：

- DOMPurify hook 会把 HTML class 从 `box` 改成 `custom-box`
- decodeStyleTags 会把 CSS selector 的 `.box` 改成 `.custom-box`

如果你在其他项目中只做了一半（例如只前缀了 CSS 没有前缀 DOM，或者反过来），也会导致不匹配。

### 2.4 你依赖了酒馆的“禁止外链媒体”逻辑 / 其它 sanitize 逻辑

SillyTavern 会根据 `isExternalMediaAllowed()` 过滤外链资源（包括 CSS 里包含 `://` 的声明）。

如果你的样式依赖外链 `background-image: url(https://...)`，在酒馆里可能本来就会被删掉；你复刻到其他项目时如果没做等价策
略，表现会不同。

---

## 3. 本插件现状的能力边界（为什么 `酒馆助手渲染方法.md` 没覆盖你这个用例）

本插件“消息渲染”管线的扫描入口如下：

```ts
const $element = $(div)
  .find('pre')
  .filter((_index, pre) => isFrontend($(pre).text()))
  .map((_index, pre) => {
    const $pre = $(pre);
    const $possible_div = $pre.parent('div.TH-render');
    if ($possible_div.length > 0) {
      return $possible_div[0];
    }
    $pre.wrap('<div class="TH-render">');
    return $pre.parent('div.TH-render')[0];
  });
```

也就是说：

- 只扫描 `pre`（代码块）
- 且必须通过 `isFrontend()`

`isFrontend()` 目前的判定也非常窄：

```ts
export function isFrontend(content: string): boolean {
  return ['html>', '<head>', '<body'].some(tag => content.includes(tag));
}
```

所以你举的“正文 `<style></style><div></div>`”根本不会被插件处理。

---

## 4. 要“完美复刻”到其他项目：你必须决定支持哪两类输入

为了把所有情况讲清楚，先把 AI 输出分为两类：

### 类型 1：代码块模式（推荐、确定性强）

- AI 输出通过 fenced code 提供整页 HTML（或明确标记的片段）
- 你从 `pre code` 取 `.textContent` 注入 iframe

这就是 `酒馆助手渲染方法.md` 的方式，优点是：

- 你拿到的是“原始代码文本”（不受 DOMPurify hooks 影响）
- 你可以决定是否允许 `<script>`、是否加载外链、是否注入桥接 API

### 类型 2：正文 HTML 片段模式（你现在碰到的）

- `<div>/<style>/<svg>...` 直接出现在正文
- 这些节点已经经历了 SillyTavern 的 sanitize + hooks + style 沙箱化

你想“渲染出来”，必须做的是“从 `.mes_text` DOM 抽取片段”并用某种方式展示：

- 方案 A：直接在消息 DOM 内渲染（不进 iframe）
- 方案 B：抽走片段塞进 iframe（但必须保持 `.mes_text` 前缀与 `custom-` 语义）

下文给的是可复刻方案（偏向 B，因为你要做跨项目复刻）。

---

## 5. 复刻方案：支持“正文 HTML 片段”的渲染（可处理 `<style></style><div></div>`）

### 5.1 总体策略（不改变酒馆安全边界）

目标：不执行“正文里的脚本”，只把已 sanitize 的 DOM 片段放到一个隔离容器中展示。

关键原则：

1. 只处理已经在 `.mes_text` 里存在的真实 DOM 节点（意味着它已经被 SillyTavern sanitize 过）
2. 抽取时必须把“style 与其作用对象”放在同一个渲染单元
3. 如果把片段放进 iframe：必须有 `.mes_text` 容器，否则 style 前缀会导致选择器失效

### 5.2 片段边界：怎么把一条消息中的多个结构拆成多个“渲染块”

这一步是你现在缺的。

建议的边界规则（尽量贴近酒馆表现 + 可实现）：

1. 当遇到 `<style>`：把它与后续一段“连续的元素节点”归为同一块，直到遇到“明显的文本段落边界”
2. 文本段落边界建议：`<p>`, `<br>`, `<hr>`, `<blockquote>`, 标题类，或纯文本节点（非空白）
3. 当遇到“可渲染根节点”但前面没有 `<style>`：以该节点为起点，同样收集连续元素节点

注意：这不是 SillyTavern 内置能力（酒馆本身只是渲染到 `.mes_text`），这是“你为了复刻而新增的一层提取策略”。

### 5.3 片段抽取（示例实现代码，跨项目可直接用）

下面这段是“从一个 `.mes_text` 容器中，把正文 HTML 片段分块”的参考实现。

输入：`mesTextEl`（HTMLElement，`.mes_text`）输出：`blocks: string[]`（每个 block 是一段 HTML，内部包含 style+dom）

```ts
export function extractInlineRenderBlocks(mesTextEl: HTMLElement): string[] {
  const blocks: string[] = [];

  const isBoundaryNode = (node: Node): boolean => {
    if (node.nodeType === Node.TEXT_NODE) {
      return Boolean(node.textContent && node.textContent.trim().length > 0);
    }
    if (node.nodeType !== Node.ELEMENT_NODE) return false;
    const tag = (node as HTMLElement).tagName.toLowerCase();
    return ['p', 'br', 'hr', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag);
  };

  const isRenderableNode = (node: Node): boolean => {
    if (node.nodeType !== Node.ELEMENT_NODE) return false;
    const tag = (node as HTMLElement).tagName.toLowerCase();

    // 按需扩展：div/span/section 等结构节点，svg/canvas 等可视节点，style 作为块起点
    return [
      'style',
      'div',
      'span',
      'section',
      'article',
      'main',
      'header',
      'footer',
      'svg',
      'canvas',
      'table',
    ].includes(tag);
  };

  const children = Array.from(mesTextEl.childNodes);
  let i = 0;
  while (i < children.length) {
    const start = children[i];

    if (!isRenderableNode(start)) {
      i++;
      continue;
    }

    // 收集从 i 开始的一段连续“可渲染元素”，遇到边界停止
    const fragment = document.createDocumentFragment();
    let j = i;
    for (; j < children.length; j++) {
      const node = children[j];
      if (isBoundaryNode(node)) break;
      if (isRenderableNode(node)) {
        fragment.appendChild(node.cloneNode(true));
        continue;
      }
      // 其他节点（注释/空白文本）跳过
    }

    const container = document.createElement('div');
    container.appendChild(fragment);
    const html = container.innerHTML.trim();
    if (html.length > 0) {
      blocks.push(html);
    }

    i = j;
  }

  return blocks;
}
```

你关心的 `<style></style><div></div>`：

- 两个节点是连续的 element，且不是边界节点
- 会被收集为同一个 block
- 不会被拆到不同 iframe

### 5.4 让 style 在 iframe 内生效：必须加 `.mes_text` 容器

因为 SillyTavern 解码 style 时给 selector 加了 `.mes_text ` 前缀（见上文 decodeStyleTags），所以你在 iframe 里必须包一
层：

```html
<body>
  <div class="mes_text">
    <!-- 这里放 extractInlineRenderBlocks 得到的 block HTML -->
  </div>
</body>
```

对应的“iframe content builder”参考实现（在你的项目中替换原来的 `createSrcContent`）：

```ts
export function createInlineFragmentIframeHtml(fragmentHtml: string) {
  return `
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      *,*::before,*::after{box-sizing:border-box;}
      html,body{margin:0;padding:0;}
    </style>
  </head>
  <body>
    <div class="mes_text">${fragmentHtml}</div>
  </body>
</html>`;
}
```

如果你不加 `.mes_text`，那么像 `.mes_text .custom-box { ... }` 永远匹配不到。

### 5.5 什么时候用“正文片段渲染”，什么时候坚持“代码块渲染”

建议优先级：

1. 如果模型输出的是 fenced code（`pre code`），优先走代码块渲染（原始文本 → iframe）
2. 否则，如果 `.mes_text` 里确实出现了 `<style>` 或结构化 DOM（div/svg/table），才尝试抽取正文片段渲染

原因：正文片段已经被 sanitize/hook 改写过，复刻时要承担更多“前缀/作用域一致性”的复杂度。

---

## 6. 本仓库层面如果要增强：应该加在哪里（以及为什么文档没提）

本仓库目前“消息 iframe 渲染”只扫描 `pre`，且是从 `code.text()` 取文本：

```ts
const content = createSrcContent($pre.find('code').text(), props.useBlobUrl);
```

如果你要让本仓库也支持“正文片段渲染”，你需要新增一个 runtime store（或扩展 `render$mes`）去扫描 `.mes_text` 的直接子节点
（或 `custom-style/style/div/svg/...`），并像 5.3 那样分块。

同时你必须考虑：

- 插件已有 `optimize_hljs`：会跳过对“前端代码块”的 hljs 处理，但它只根据 `isFrontend($(element).text())` 判定。
- 对正文片段来说，你根本不需要 hljs；所以扫描策略要避开 `pre code` 与 hljs 注入后的结构。
- 插件的 `macro_like` 会在渲染后 `.$mes_text.html(...)` 替换宏，并会移除 `.TH-render > iframe`：

```ts
$mes_text.find('.TH-render > iframe').remove();
$mes_text.html((_index, html) => replace_html(html));
```

这意味着你新增“正文片段渲染”时要定义清楚顺序：

1. 先做 macro_like 的 DOM 替换
2. 再做片段抽取/渲染

否则会出现“先渲染 iframe，再被 macro_like 误删/覆盖”的问题。

---

## 7. 必须覆盖的特殊情况清单（复刻时逐条对齐）

下面按“输入形态”列出你必须处理的情况，并给推荐策略。

### 7.1 正文里只有 `<style>`，后面没有结构节点

酒馆会把它 decode 成 `<style>...</style>` 并前缀化，但如果没有可匹配节点，它就是“无效果”。

复刻策略：

- 你可以忽略（不渲染），或把它与后续最近一个可渲染块合并（需要定义最大距离/边界）。

### 7.2 正文里 `<style></style><div></div>`，且一个消息里重复出现多组

复刻策略：

- 用 5.3 的分块策略，确保每一组 `<style> + 后续连续结构` 在同一个 iframe。

### 7.3 正文里 `<div>...</div>` 没有 `<style>`

复刻策略：

- 仍可作为独立 block 渲染（带 `.mes_text` wrapper）。
- 注意它的 class 可能已经被改成 `custom-xxx`。

### 7.4 正文里出现 `<script>`

在酒馆 display 链路，`messageFormatting` 的输出经过 DOMPurify，脚本通常会被移除或失效（具体取决于 DOMPurify 配置）。

复刻建议：

- 不要尝试执行正文里的 script。
- 如果你确实需要“正文脚本执行”，那已经偏离酒馆安全模型，必须改为“代码块模式”并在 iframe 内执行。

### 7.5 正文里出现 `<body>`/`<head>`/`<html>`

这类标签出现在正文，经过 sanitize 后可能会被丢弃/扁平化，表现不稳定。

复刻建议：

- 不把它当成“整页 HTML”，仍按“片段模式”处理：抽取 DOM 节点，塞进 iframe 的 `.mes_text` 容器。
- 只有代码块模式才允许整页 HTML。

### 7.6 外链资源（CSS/IMG/VIDEO）

SillyTavern 的 hooks 会在 `isExternalMediaAllowed()` 为 false 时移除外链媒体节点，并在 CSS declarations 里过滤 `://`。

复刻建议：

- 如果你的目标是“等价复刻酒馆”，就要实现同等的外链策略。
- 如果你的目标是“更强渲染能力”，你需要明确写出安全例外与白名单来源。

---

## 8. 最小结论：如何让你的其他项目正确渲染 `<style></style><div></div>`

只给你可立即落地的要点：

1. 不要把 `<style>` 和 `<div>` 拆成不同 iframe。
2. 如果你的输入来自“酒馆处理后的 HTML”，要么：
   - 在 iframe 内包一层 `<div class="mes_text">...</div>`（推荐，最不容易错）
   - 要么把 CSS selector 的 `.mes_text ` 前缀去掉（不推荐，容易破坏复杂选择器）
3. 记住 class 前缀：酒馆会把 `class="box"` 变成 `class="custom-box"`，CSS 也会变成 `.custom-box`。

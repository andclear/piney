# 酒馆助手渲染方法（JS-Slash-Runner / Tavern-Helper）

目标：把“AI 输出里的 HTML/CSS/JS 代码”在 SillyTavern 聊天界面中渲染成可交互内容。

本文基于本仓库代码与 SillyTavern release 分支的真实代码片段，总结一套可复刻的实现。

注意：本文不使用任何 markdown 链接；如需溯源，直接给出纯文本 URL。

---

## 1. 这套渲染能力到底做了什么

核心思想不是“让聊天消息里的 HTML 直接执行”，而是：

1. 让 SillyTavern 按它原本的流程把 AI 输出显示出来（markdown -> HTML）

2. 在“消息已经渲染到 DOM 后”，扫描消息 DOM 里 `<pre>` 代码块

3. 识别其中“看起来是前端页面的代码块”，把它包起来

4. 用 Vue Teleport 把一个 iframe 挂载进去

5. 把代码块里的纯文本当作 iframe 的 `<body>` 内容（或 script 内容），在 iframe 内执行

这样：

- 聊天消息本体仍然是安全的文本展示（受 SillyTavern 的 DOMPurify/escape 影响）
- 真正的 HTML/CSS/JS 在 iframe 隔离环境中跑

---

## 2. “Markdown vs HTML” 在这里怎么判断、怎么分流

### 2.1 插件本身不解析 markdown

本仓库的“消息渲染”依赖 SillyTavern 内置的 markdown 处理器。

本仓库仅在 DOM 层做判断：只看“已经被 SillyTavern 渲染出来的 `<pre>` 代码块文本”是否像一个 HTML 页面。

识别函数非常简单：

文件：`src/util/is_frontend.ts`

```ts
export function isFrontend(content: string): boolean {
  return ['html>', '<head>', '<body'].some(tag => content.includes(tag));
}
```

判定结果影响两件事：

1. 是否把该 `<pre>` 包装成 `div.TH-render` 并渲染 iframe

2. 是否跳过高亮、是否折叠等 UI 行为

### 2.2 “HTML 的处理”实际上是“HTML 代码块的处理”

插件只处理 `<pre>`（代码块）里的文本：

- 你需要让 AI 输出形成代码块（典型是 markdown fence，例如 `html ... `）
- SillyTavern 会把它渲染成 `<pre><code>...</code></pre>`
- 插件读的是 `code.text()` 的纯文本，并不会执行聊天消息 DOM 里的 HTML

这也是为什么聊天消息里就算包含 `<script>`，通常也不会直接运行：

- 聊天消息渲染有 DOMPurify sanitize（见第 4 节）
- 插件执行的是“代码块文本”，通过 iframe 的 `srcdoc` / blob URL 注入

---

## 3. 从“AI 输出文本”到“iframe 渲染”的完整流水线（本仓库）

### 3.1 入口：监听消息渲染事件，扫描 DOM

文件：`src/store/iframe_runtimes/message.ts`

关键逻辑：

1. 选出聊天楼层 DOM：`#chat > .mes`

2. 找到其中的 `pre`

3. 用 `isFrontend($(pre).text())` 过滤

4. 用 `<div class="TH-render">` 包装 `<pre>`，作为 Teleport 目标容器

```ts
function render$mes($mes: JQuery<HTMLElement>, reload_memo: string): Runtime[] {
  return _($mes.toArray())
    .map(div => {
      const message_id = Number($(div).attr('mesid'));
      const $element = $(div)
        .find('pre')
        .filter((_index, pre) => isFrontend($(pre).text()))
        .map((_index, pre) => {
          const $pre = $(pre);
          const $possible_div = $pre.parent('div.TH-render');
          if ($possible_div.length > 0) {
            return $possible_div[0];
          }
          $pre.wrap('<div class="TH-render">');
          return $pre.parent('div.TH-render')[0];
        });
      return { message_id, reload_memo, elements: $element.toArray() };
    })
    .filter(({ elements }) => elements.length > 0)
    .value();
}
```

同时，它通过事件保持“增量更新”：

```ts
[
  event_types.CHARACTER_MESSAGE_RENDERED,
  event_types.USER_MESSAGE_RENDERED,
  event_types.MESSAGE_UPDATED,
  event_types.MESSAGE_SWIPED,
].forEach(event => {
  eventSource.on(event, (message_id: number | string) => {
    // enabled 时重新扫描该楼层
  });
});
```

### 3.2 渲染深度（只渲染最近 N 楼）

文件：`src/store/iframe_runtimes/message.ts`

```ts
function calcToRender(depth: number): number[] {
  const min_showed_message_id = Number($('#chat > .mes').first().attr('mesid'));
  return _.range(
    depth === 0 ? min_showed_message_id : Math.max(min_showed_message_id, chat.length - depth),
    chat.length,
  );
}
```

### 3.3 Vue Teleport：把 iframe 挂到每个 `div.TH-render`

文件：`src/panel/Render.vue`

```vue
<template v-for="{ message_id, reload_memo, elements } in runtimes" :key="message_id + reload_memo">
  <Teleport v-for="(element, index) in elements" :key="index" defer :to="element">
    <Iframe :id="`${message_id}--${index}`" :element="element" :use-blob-url="use_blob_url" />
  </Teleport>
</template>
```

这里的关键点：

- Teleport 的 `to` 是一个真实 DOM 元素（`div.TH-render`）
- `reload_memo` 改变会强制重建 iframe（用于实时刷新）

### 3.4 Iframe 组件：从 `<pre><code>` 抽取纯文本，塞进 iframe

文件：`src/panel/render/Iframe.vue`

```ts
const $div = $(props.element);
const $pre = $div.children('pre');

const src_prop = computed((old_src_prop?: { srcdoc?: string; src?: string }) => {
  if (old_src_prop?.src) {
    URL.revokeObjectURL(old_src_prop.src);
  }

  const content = createSrcContent($pre.find('code').text(), props.useBlobUrl);
  if (!props.useBlobUrl) {
    return { srcdoc: content };
  }
  return { src: URL.createObjectURL(new Blob([content], { type: 'text/html' })) };
});
```

关键点：

- 读的是 `$pre.find('code').text()`（纯文本）
- 通过 `srcdoc` 或 `Blob URL` 注入整页 HTML

### 3.5 iframe 内页面模板：注入依赖库、环境脚本、再把用户内容放进 `<body>`

文件：`src/panel/render/iframe.ts`

```ts
export function createSrcContent(content: string, use_blob_url: boolean) {
  content = replaceVhInContent(content);

  return `
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
${use_blob_url ? `<base href="${window.location.origin}"/>` : ''}
<style>
*,*::before,*::after{box-sizing:border-box;}
html,body{margin:0!important;padding:0;overflow:hidden!important;max-width:100%!important;}
.user_avatar,.user-avatar{background-image:url('${getUserAvatarPath()}')}
.char_avatar,.char-avatar{background-image:url('${getCharAvatarPath()}')}
</style>
${third_party}
<script src="${predefine_url}"></script>
<script src="https://testingcf.jsdelivr.net/gh/N0VI028/JS-Slash-Runner/src/iframe/node_modules/log.js"></script>
<script src="${adjust_viewport_url}"></script>
<script src="${adjust_iframe_height_url}"></script>
</head>
<body>
${content}
</body>
</html>
`;
}
```

第三方库清单（消息 iframe）：

文件：`src/iframe/third_party_message.html`

```html
<link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" />
<script src="/scripts/extensions/third-party/JS-Slash-Runner/lib/tailwindcss.min.js"></script>
<script src="https://testingcf.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
<script src="https://testingcf.jsdelivr.net/npm/jquery-ui/dist/jquery-ui.min.js"></script>
<link rel="stylesheet" href="https://testingcf.jsdelivr.net/npm/jquery-ui/themes/base/theme.min.css" />
<script src="https://testingcf.jsdelivr.net/npm/jquery-ui-touch-punch"></script>
<script src="https://testingcf.jsdelivr.net/npm/vue/dist/vue.runtime.global.prod.min.js"></script>
<script src="https://testingcf.jsdelivr.net/npm/vue-router/dist/vue-router.global.prod.min.js"></script>
<script src="https://testingcf.jsdelivr.net/npm/pixi.js/dist/pixi.min.js"></script>
```

---

## 4. SillyTavern 自身如何处理 Markdown 与 HTML（关键点）

你要复刻能力时，必须分清两条路径：

- “展示用消息渲染”（markdown -> HTML -> sanitize -> `.mes_text.innerHTML`）
- “代码块文本被插件抽走后，在 iframe 内运行”（不走消息渲染 sanitize）

### 4.1 markdown 处理器：Showdown Converter

来源（SillyTavern release）：`public/script.js`

纯文本 URL： https://github.com/SillyTavern/SillyTavern/blob/release/public/script.js

片段（reloadMarkdownProcessor）：

```js
export function reloadMarkdownProcessor() {
    converter = new showdown.Converter({
        emoji: true,
        literalMidWordUnderscores: true,
        parseImgDimensions: true,
        tables: true,
```

本仓库对 markdown 渲染的调用（用于弹窗/说明等 UI，不是聊天楼层）：

文件：`src/util/tavern.ts`

```ts
export function renderMarkdown(markdown: string) {
  return reloadMarkdownProcessor().makeHtml(markdown);
}
```

### 4.2 消息渲染最终会做 sanitize（DOMPurify）

来源（SillyTavern release）：`public/script.js`

片段（messageFormatting 的末尾 sanitize 流程）：

```js
    const config = {
        RETURN_DOM: false,
        RETURN_DOM_FRAGMENT: false,
        RETURN_TRUSTED_TYPE: false,
        MESSAGE_SANITIZE: true,
        ADD_TAGS: ['custom-style'],
        ...sanitizerOverrides,
    };
    mes = encodeStyleTags(mes);
    mes = DOMPurify.sanitize(mes, config);
    mes = decodeStyleTags(mes, { prefix: '.mes_text ' });

    return mes;
}
```

另外，SillyTavern 还存在一个“把 `<`/`>` 转义掉”的选项（避免 HTML 被当成标签）：

来源（SillyTavern release）：`public/script.js`

```js
if (!isSystem && power_user.encode_tags) {
  mes = canUseNegativeLookbehind()
    ? mes.replaceAll('<', '&lt;').replace(new RegExp('(?<!^|\\n\\s*)>', 'g'), '&gt;')
    : mes.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
}
```

对应的 `<style>` 特殊处理来自：`public/scripts/chats.js`

```js
export function encodeStyleTags(text) {
  const styleRegex = /<style>(.+?)<\/style>/gims;
  return text.replaceAll(styleRegex, (_, match) => {
    return `<custom-style>${encodeURIComponent(match)}</custom-style>`;
  });
}
```

结论：

- 聊天消息 HTML 不是“原样信任执行”的，最终会经过 DOMPurify
- 但插件执行的是“代码块纯文本”→ iframe 的 `srcdoc/blob`，这条路径绕开了消息 sanitize

### 4.3 代码围栏（```）为什么会变成 `<pre><code>`（间接证据：后处理选择器就是 `pre code`）

SillyTavern 的后处理逻辑明确假设 Markdown 渲染结果里存在 `pre code` 结构，并在消息更新后遍历它们：

来源（SillyTavern release）：`public/script.js`

```js
export function addCopyToCodeBlocks(messageElement) {
  const codeBlocks = $(messageElement).find('pre code');
  for (let i = 0; i < codeBlocks.length; i++) {
    hljs.highlightElement(codeBlocks.get(i));
    const copyButton = document.createElement('i');
    copyButton.classList.add('fa-solid', 'fa-copy', 'code-copy', 'interactable');
    copyButton.title = 'Copy code';
    codeBlocks.get(i).appendChild(copyButton);
    // ...
  }
}
```

以及消息重渲染后会调用它：

```js
export function updateMessageBlock(messageId, message, { rerenderMessage = true } = {}) {
  const messageElement = chatElement.find(`[mesid="${messageId}"]`);
  if (rerenderMessage) {
    const text = message?.extra?.display_text ?? message.mes;
    messageElement
      .find('.mes_text')
      .html(messageFormatting(text, message.name, message.is_system, message.is_user, messageId, {}, false));
  }

  updateReasoningUI(messageElement);

  addCopyToCodeBlocks(messageElement);
  appendMediaToMessage(message, messageElement);
}
```

---

## 5. SillyTavern 正则系统（markdownOnly / promptOnly）与本插件的结合

本仓库在做“把文本按酒馆正则处理一遍”时，会明确告诉 SillyTavern：这是展示用还是 prompt 用。

文件：`src/function/tavern_regex.ts`

```ts
let result = getRegexedString(
  text,
  (
    {
      user_input: regex_placement.USER_INPUT,
      ai_output: regex_placement.AI_OUTPUT,
      slash_command: regex_placement.SLASH_COMMAND,
      world_info: regex_placement.WORLD_INFO,
      reasoning: regex_placement.REASONING,
    } as const
  )[source],
  {
    characterOverride: character_name,
    isMarkdown: destination === 'display',
    isPrompt: destination === 'prompt',
    depth,
  },
);
```

上游（SillyTavern）regex 引擎的关键条件（commit 7a497421bb6c1388a2e6da1ab1e799f0bc98c974）：

纯文本 URL：
https://github.com/SillyTavern/SillyTavern/blob/7a497421bb6c1388a2e6da1ab1e799f0bc98c974/public/scripts/extensions/regex/engine.js

```js
export function getRegexedString(
  rawString,
  placement,
  { characterOverride, isMarkdown, isPrompt, isEdit, depth } = {},
) {
  if (typeof rawString !== 'string') {
    console.warn('getRegexedString: rawString is not a string. Returning empty string.');
    return '';
  }

  if (
    (script.markdownOnly && isMarkdown) ||
    (script.promptOnly && isPrompt) ||
    (!script.markdownOnly && !script.promptOnly && !isMarkdown && !isPrompt)
  ) {
    // ...
  }
}
```

结论：

- 你如果要复刻“酒馆正则后的显示效果”，需要同样区分 display/prompt
- `markdownOnly` 只在 display 渲染时跑；`promptOnly` 只在 prompt 构建时跑
- 这会影响“你在聊天里看到什么”和“AI 实际收到什么”

---

## 6. 本插件对 HTML/CSS/JS 的执行环境与隔离（以及实际没那么隔离的点）

### 6.1 iframe 环境注入（predefine.js）

文件：`src/iframe/predefine.js`

```js
window._ = window.parent._;
Object.defineProperty(window, 'SillyTavern', {
  get: () => _.get(window.parent, 'SillyTavern').getContext(),
});

let result = _(window);
result = result.merge(_.pick(window.parent, ['EjsTemplate', 'TavernHelper', 'YAML', 'showdown', 'toastr', 'z']));
result = result.merge(_.omit(_.get(window.parent, 'TavernHelper'), '_bind'));
result = result.merge(
  ...Object.entries(_.get(window.parent, 'TavernHelper')._bind).map(([key, value]) => ({
    [key.replace('_', '')]: value.bind(window),
  })),
);
result.value();
```

这段非常关键：

- iframe 并不是一个“与宿主完全隔离”的沙箱
- 它能通过注入拿到 `SillyTavern.getContext()`、以及大量 TavernHelper 绑定函数
- 所以：从安全角度，它更像“隔离 DOM，但共享能力接口”

### 6.2 视口高度同步 + vh 修正

文件：`src/iframe/adjust_viewport.js`

```js
$('html').css('--TH-viewport-height', `${window.parent.innerHeight}px`);
window.addEventListener('message', function (event) {
  if (event.data?.type === 'TH_UPDATE_VIEWPORT_HEIGHT') {
    $('html').css('--TH-viewport-height', `${window.parent.innerHeight}px`);
  }
});
```

文件：`src/panel/render/iframe.ts`（只针对 `min-height: ...vh` 做替换，且覆盖 CSS/inline style/JS setProperty 场景）

```ts
const VARIABLE_EXPRESSION = `var(--TH-viewport-height)`;
if (parsed === 100) {
  return VARIABLE_EXPRESSION;
}
return `calc(${VARIABLE_EXPRESSION} * ${parsed / 100})`;
```

### 6.3 自动高度：iframe 内测量 -> postMessage -> 父页面设置高度

文件：`src/iframe/adjust_iframe_height.js`

```js
const IS_BLOB_MODE = window.location.protocol === 'blob:';

function measureAndPost() {
  let height = 0;
  if (IS_BLOB_MODE) {
    // blob 模式: 子元素高度算法（排除 absolute/fixed），失败则 fallback 到 scrollHeight
    // ...
    if (!Number.isFinite(height) || height <= 0) {
      height = body.scrollHeight;
    }
  } else {
    // srcdoc 模式: 只用 body.scrollHeight
    height = body.scrollHeight;
  }
  window.parent.postMessage({ type: 'TH_ADJUST_IFRAME_HEIGHT', iframe_name: getIframeName(), height: height }, '*');
}
```

父页面（Vue Iframe 组件）监听并设置高度：

文件：`src/panel/render/Iframe.vue`

```ts
useEventListener('message', event => {
  if (event?.data?.type === 'TH_ADJUST_IFRAME_HEIGHT' && event?.data?.iframe_name === iframe_ref.value?.id) {
    iframe_ref.value!.style.height = `${event.data.height}px`;
  }
});
```

---

## 7. “脚本运行”是另一条并行管线（隐藏 iframe）

除了“消息里的前端代码块渲染”，本仓库还支持“脚本库/全局脚本”通过隐藏 iframe 执行。

### 7.1 脚本 iframe 的 HTML 模板不同：用 `<script type="module">` 注入

文件：`src/panel/script/iframe.ts`

```ts
export function createSrcContent(content: string, use_blob_url: boolean) {
  return `<html>
<head>
<script src="${parent_jquery_url}"></script>
${third_party}
${use_blob_url ? `<base href="${window.location.origin}"/>` : ''}
<script src="${predefine_url}"></script>
<script src="https://testingcf.jsdelivr.net/gh/N0VI028/JS-Slash-Runner/src/iframe/node_modules/log.js"></script>
</head>
<body>
<script type="module">
${content}
</script>
</body>
</html>
`;
}
```

文件：`src/panel/script/Iframe.vue`

```vue
<iframe v-show="false" :id="`TH-script--${name}--${id}`" :name="`TH-script--${name}--${id}`" v-bind="src_prop" />
```

这条管线的目的：执行 JS（不渲染 UI），并通过 `TavernHelper`/事件系统与酒馆交互。

---

## 8. 其他关键细节（你复刻时很容易漏）

### 8.1 折叠代码块（避免聊天被大段代码撑爆）

文件：`src/panel/render/use_collapse_code_block.ts`

特点：

- 按配置折叠：`none` / `frontend_only` / `all`
- 对前端代码块：如果已经渲染出 iframe，会隐藏折叠按钮
- 在流式生成过程中用 MutationObserver 追踪 DOM 变化，及时折叠最新楼层

### 8.2 语法高亮的副作用处理

文件：`src/panel/render/optimize_hljs.ts`

```ts
hljs.highlightElement = (element: HTMLElement) => {
  if (isFrontend($(element).text())) {
    return;
  }
  originalHighlightElement(element);
};
```

目的：避免 highlight.js 破坏“用于 iframe 执行的原始代码文本”。

### 8.3 宏替换：两套机制

1. SillyTavern 宏（MacrosParser）

文件：`src/macro.ts`

```ts
const macros = {
  userAvatarPath: getUserAvatarPath,
  charAvatarPath: getCharAvatarPath,
};

export function registerMacros() {
  for (const [key, value] of Object.entries(macros)) {
    MacrosParser.registerMacro(key, value);
  }
}
```

2. 本插件“助手宏”（macro_like）：主要用于变量读取与格式化

文件：`src/function/macro_like.ts`

```ts
export const macros: MacroLike[] = [
  {
    regex: /\{\{get_(message|chat|character|preset|global)_variable::(.*?)\}\}/gi,
    replace: (context, _substring, type, path) => {
      const variables = get_variables_without_clone(
        type !== 'message'
          ? { type }
          : { type, message_id: context.message_id ?? chat.findLastIndex(...) },
      );
      const value = omitDeepBy(_.get(variables, _.unescape(path), null), (_, key) => key.startsWith('$'));
      return typeof value === 'string' ? value : JSON.stringify(value);
    },
  },
  {
    regex: /^(.*)\{\{format_(message|chat|character|preset|global)_variable::(.*?)\}\}/gim,
    replace: (context, _substring, prefix, type, path) => {
      // YAML stringify + 缩进
    },
  },
];
```

而 `src/panel/render/macro_like.ts` 会在“消息渲染到 DOM 后”再次替换 `.mes_text` 的 HTML 与 `<code>` 文本。

这一步对复刻很重要：

- 只在 prompt 阶段替换宏不够
- 因为聊天 DOM 是由 SillyTavern 再渲染一遍的，宏可能重新出现

---

## 9. 复刻到你的项目：建议的最小实现清单

如果你的项目不是 SillyTavern，但你要复刻“AI 输出渲染 HTML/CSS/JS”的能力，可以按下面拆分：

1. 文本展示层（Markdown -> HTML）

- 选用 showdown/marked/markdown-it 任意一个
- 输出 HTML 后一定要 sanitize（DOMPurify 等），防止聊天区执行脚本

2. 前端代码块识别

- 最简单：仿照 `isFrontend()` 检测 `<head>/<body>/html>`
- 更稳：检测 ```html fence / 语言标记 / 或强制协议（例如让模型输出 `<!-- TH_FRONTEND -->`）

3. DOM 扫描与挂载点准备

- 扫描渲染后的消息 DOM，找到代码块元素
- 用一个 wrapper（如 `.TH-render`）包装，作为 iframe 的宿主节点

4. iframe 渲染

- 用 `srcdoc` 或 Blob URL
- iframe 内容模板里注入：基础 CSS + 你需要的第三方库 + 你的桥接 API（如 postMessage / host SDK）

5. 高度自适应

- iframe 内 ResizeObserver/MutationObserver
- `postMessage` 回传高度，父页面设置 `iframe.style.height`

6. （可选）vh 处理

- 如果你遇到移动端 `100vh` 问题，可用本文的 `--TH-viewport-height` 思路

---

## 10. 安全与风险提示（务必写进你的项目 README）

这套能力本质上是“运行第三方代码”。

本仓库通过 iframe 避免直接污染聊天 DOM，但仍然：

- 注入了 `SillyTavern.getContext()`、`TavernHelper` 等强能力对象到 iframe
- 这意味着恶意代码可以读写大量宿主状态（聊天、设置、密钥等，取决于宿主暴露的能力）

如果你要在自己的项目复刻，建议至少做到：

- 默认不开启“共享宿主上下文”能力；只暴露最小 API
- 对外部脚本来源做白名单
- 对 iframe 使用更严格的 sandbox（如果你不需要同源能力）

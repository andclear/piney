# 正则在酒馆中的实现

本文档描述 SillyTavern（酒馆）“正则脚本（Regex extension）”是如何对文本（尤其是 AI 输出）做查找/替换的，以及它在聊天 JSONL 存储与 UI/提示词生成（prompt）中的生效位置与差异。

你要在其他项目里“读 JSONL 聊天记录并复刻酒馆正则效果”，关键不是“正则语法多高级”，而是：

- 酒馆把“正则脚本”当作一条条规则链（有来源/开关/作用范围/深度过滤/宏替换等），按固定顺序跑。
- 同一条规则在不同阶段会以不同参数运行：显示渲染（markdownOnly）、发请求构建 prompt（promptOnly）、以及**持久化改写聊天内容**（两者都不是）。
- `Find Regex` 的字符串不是简单 `new RegExp(str)`：它允许 `/pattern/flags` 形式，并有一套 flags 校验/回退逻辑。

下文所有“代码片段”均为酒馆原生实现的关键部分（去掉了行号与文件路径）。

---

## 1. 规则数据结构（RegexScript）与来源

酒馆把每条正则规则保存为一个对象（下称 `RegexScript`）。UI 编辑器会读写这些字段（字段名即 JSON key）。

核心字段：

- `id: string`：UUID。
- `scriptName: string`：规则名。
- `findRegex: string`：查找表达式（支持纯字符串或 `/.../flags`）。
- `replaceString: string`：替换模板。
- `trimStrings: string[]`：在把捕获组插入替换模板前，先对捕获内容做“全局剪除”的字符串列表。
- `placement: number[]`：作用范围（详见后文 placement 枚举）。
- `disabled: boolean`：禁用。
- `markdownOnly: boolean`：仅显示渲染时生效（不改聊天文件）。
- `promptOnly: boolean`：仅构建 prompt 时生效（不改聊天文件）。
- `runOnEdit: boolean`：消息编辑保存时才运行（与持久化/only 逻辑共同决定）。
- `substituteRegex: number`：Find Regex 是否先做宏替换（NONE/RAW/ESCAPED）。
- `minDepth/maxDepth: number|null`：深度过滤。

规则来源（合并后形成“规则链”）：

1) 全局规则（Global）
2) 预设规则（Preset）
3) 角色卡局部规则（Scoped）

三类规则不仅存储位置不同，还各自有“允许使用”的开关（角色卡局部/预设可以被整体禁用）。

对应实现片段（规则类型与合并顺序，注意注释 `ORDER MATTERS`，以及 `Object.values(SCRIPT_TYPES)` 的顺序）：

```js
/**
 * @readonly
 * @enum {number} Regex scripts types
 */
export const SCRIPT_TYPES = {
    // ORDER MATTERS: defines the regex script priority
    GLOBAL: 0,
    PRESET: 2,
    SCOPED: 1,
};

export function getRegexScripts(options = DEFAULT_GET_REGEX_SCRIPTS_OPTIONS) {
    return [...Object.values(SCRIPT_TYPES).flatMap(type => getScriptsByType(type, options))];
}
```

以及三类来源的取数逻辑（节选）：

```js
export function getScriptsByType(scriptType, { allowedOnly } = DEFAULT_GET_REGEX_SCRIPTS_OPTIONS) {
    switch (scriptType) {
        case SCRIPT_TYPES.GLOBAL:
            return extension_settings.regex ?? [];
        case SCRIPT_TYPES.SCOPED: {
            if (allowedOnly && !extension_settings?.character_allowed_regex?.includes(characters?.[this_chid]?.avatar)) {
                return [];
            }
            const scopedScripts = characters[this_chid]?.data?.extensions?.regex_scripts;
            return Array.isArray(scopedScripts) ? scopedScripts : [];
        }
        case SCRIPT_TYPES.PRESET: {
            if (allowedOnly && !extension_settings?.preset_allowed_regex?.[getCurrentPresetAPI()]?.includes(getCurrentPresetName())) {
                return [];
            }
            const presetManager = getPresetManager();
            const presetScripts = presetManager?.readPresetExtensionField({ path: 'regex_scripts' });
            return Array.isArray(presetScripts) ? presetScripts : [];
        }
        default:
            return [];
    }
}
```

---

## 2. placement：规则“影响哪类文本”

placement 用数字枚举表示：

```js
export const regex_placement = {
    /**
     * @deprecated MD Display is deprecated. Do not use.
     */
    MD_DISPLAY: 0,
    USER_INPUT: 1,
    AI_OUTPUT: 2,
    SLASH_COMMAND: 3,
    // 4 - sendAs (legacy)
    WORLD_INFO: 5,
    REASONING: 6,
};
```

你在外部项目里处理 JSONL 时，最常见的就是区分 `USER_INPUT(1)` 与 `AI_OUTPUT(2)`。

---

## 3. 正则脚本的三种“生效模式”

酒馆把同一套规则用于三个阶段：

1) **显示渲染（Display-only）**：`isMarkdown: true`，只运行 `markdownOnly: true` 的脚本。
2) **构建 Prompt（Prompt-only）**：`isPrompt: true`，只运行 `promptOnly: true` 的脚本。
3) **持久化改写（Persistent rewrite）**：既不是 markdown 也不是 prompt；只运行 `markdownOnly=false && promptOnly=false` 的脚本。该模式的输出会写回聊天消息对象，最终落盘到 JSONL。

这三种模式的判定逻辑是 `getRegexedString` 的核心：

```js
export function getRegexedString(rawString, placement, { characterOverride, isMarkdown, isPrompt, isEdit, depth } = {}) {
    if (typeof rawString !== 'string') {
        console.warn('getRegexedString: rawString is not a string. Returning empty string.');
        return '';
    }

    let finalString = rawString;
    if (extension_settings.disabledExtensions.includes('regex') || !rawString || placement === undefined) {
        return finalString;
    }

    const allRegex = getRegexScripts({ allowedOnly: true });
    allRegex.forEach((script) => {
        if (
            (script.markdownOnly && isMarkdown) ||
            (script.promptOnly && isPrompt) ||
            (!script.markdownOnly && !script.promptOnly && !isMarkdown && !isPrompt)
        ) {
            if (isEdit && !script.runOnEdit) {
                console.debug(`getRegexedString: Skipping script ${script.scriptName} because it does not run on edit`);
                return;
            }

            if (typeof depth === 'number') {
                if (!isNaN(script.minDepth) && script.minDepth !== null && script.minDepth >= -1 && depth < script.minDepth) {
                    return;
                }
                if (!isNaN(script.maxDepth) && script.maxDepth !== null && script.maxDepth >= 0 && depth > script.maxDepth) {
                    return;
                }
            }

            if (script.placement.includes(placement)) {
                finalString = runRegexScript(script, finalString, { characterOverride });
            }
        }
    });

    return finalString;
}
```

重要细节：注释里明确写了“在 markdown 渲染时没必要再跑持久化脚本，因为来源（chat history）应该已经提前被改写”。因此，若你在外部项目里仅“渲染显示”，应该只跑 `markdownOnly`；若你想复刻“聊天文件最终保存的文本”，则只跑持久化脚本。

---

## 4. 规则链执行顺序与缓存

### 4.1 执行顺序

执行顺序来自 `getRegexScripts()` 合并三类来源后的顺序。由于 `SCRIPT_TYPES` 的对象属性插入顺序是 `GLOBAL -> PRESET -> SCOPED`，因此规则链整体优先级为：

1) Global
2) Preset
3) Scoped

每条脚本是串行执行：上一条脚本的输出会作为下一条脚本的输入。

### 4.2 编译缓存（RegexProvider）

酒馆用 LRU 缓存编译后的 `RegExp`，并对 `g/y` 重置 `lastIndex`：

```js
export class RegexProvider {
    #cache = new Map();
    #maxSize = 1000;

    static instance = new RegexProvider();

    get(regexString) {
        const isCached = this.#cache.has(regexString);
        const regex = isCached
            ? this.#cache.get(regexString)
            : regexFromString(regexString);

        if (!regex) {
            return null;
        }

        if (isCached) {
            this.#cache.delete(regexString);
            this.#cache.set(regexString, regex);
        } else {
            if (this.#cache.size >= this.#maxSize) {
                const firstKey = this.#cache.keys().next().value;
                this.#cache.delete(firstKey);
            }
            this.#cache.set(regexString, regex);
        }

        if (regex.global || regex.sticky) {
            regex.lastIndex = 0;
        }

        return regex;
    }
}
```

---

## 5. Find Regex 字符串的解析与 flags 支持

`findRegex` 的解析不是“酒馆自定义正则语法”，而是“基于 JavaScript RegExp，但允许你用 `/pattern/flags` 字面量形式写在字符串里”。

解析实现如下（完全照搬）：

```js
export function regexFromString(input) {
    try {
        // Parse input
        var m = input.match(/(\/?)(.+)\1([a-z]*)/i);

        // Invalid flags
        if (m[3] && !/^(?!.*?(.).*?\1)[gmixXsuUAJ]+$/.test(m[3])) {
            return RegExp(input);
        }

        // Create the regular expression
        return new RegExp(m[2], m[3]);
    } catch {
        return;
    }
}
```

它的语义（非常关键，很多外部复刻会踩坑）：

- `input` 可以是 `"plain pattern"`，也可以是 `"/pattern/flags"`。
- `flags` 校验：
  - 仅允许字符集合 `[gmixXsuUAJ]`；并且不允许重复。
  - 若 `flags` 校验失败，则走 `RegExp(input)`（把整个原字符串当作 pattern，而不是去掉两侧 `/`）。这会导致“你以为你写了 `/blue/gi`，但被当成字面字符串去匹配”。
- 真实能否工作，仍取决于运行环境（浏览器）对 `new RegExp(pattern, flags)` 的支持；如果 flags 包含环境不支持的标志，会抛异常并被 `catch` 捕获，最终返回 `undefined`，导致该脚本不生效。

因此：

- 要全局替换必须显式使用 `g`。
- 要跨行匹配，常见做法是 `s`（dotAll）或 `[ -\uFFFF]`/`[\s\S]`。

---

## 6. Replace String 支持的占位符与捕获组

酒馆的替换分两阶段：

1) 先处理 `{{match}}`、`$1/$2...`、`$<name>` 这类“正则捕获组引用”。
2) 再对拼接后的最终结果跑一遍宏替换（`substituteParams(...)`）。

核心实现（完全照搬）：

```js
export function runRegexScript(regexScript, rawString, { characterOverride } = {}) {
    let newString = rawString;
    if (!regexScript || !!(regexScript.disabled) || !regexScript?.findRegex || !rawString) {
        return newString;
    }

    const getRegexString = () => {
        switch (Number(regexScript.substituteRegex)) {
            case substitute_find_regex.NONE:
                return regexScript.findRegex;
            case substitute_find_regex.RAW:
                return substituteParamsExtended(regexScript.findRegex);
            case substitute_find_regex.ESCAPED:
                return substituteParamsExtended(regexScript.findRegex, {}, sanitizeRegexMacro);
            default:
                console.warn(`runRegexScript: Unknown substituteRegex value ${regexScript.substituteRegex}. Using raw regex.`);
                return regexScript.findRegex;
        }
    };
    const regexString = getRegexString();
    const findRegex = RegexProvider.instance.get(regexString);

    if (!findRegex) {
        return newString;
    }

    newString = rawString.replace(findRegex, function (match) {
        const args = [...arguments];
        const replaceString = regexScript.replaceString.replace(/{{match}}/gi, '$0');
        const replaceWithGroups = replaceString.replaceAll(/\$(\d+)|\$<([^>]+)>/g, (_, num, groupName) => {
            if (num) {
                match = args[Number(num)];
            } else if (groupName) {
                const groups = args[args.length - 1];
                match = groups && typeof groups === 'object' && groups[groupName];
            }

            if (!match) {
                return '';
            }

            const filteredMatch = filterString(match, regexScript.trimStrings, { characterOverride });
            return filteredMatch;
        });

        // Substitute at the end
        return substituteParams(replaceWithGroups);
    });

    return newString;
}
```

从实现可以严格得出：

- `{{match}}`：大小写不敏感替换为 `$0`（整段匹配）。
- `$1`、`$2`...：数字捕获组；**如果对应捕获组为空/不存在，则插入空字符串**。
- `$<name>`：命名捕获组；依赖 JS 的 `groups`（回调参数最后一个）。

注意：

- 这里处理的是 `$<name>`，而不是 JS 原生 replacement string 支持的 `'$<name>'` 语义；酒馆是自己手动替换的。
- 处理 `$n`/`$<name>` 的逻辑发生在 `substituteParams(...)` 之前。

---

## 7. Trim Out（trimStrings）的语义

Trim Out 的作用范围不是“对整条消息 trim”，而是：

- 仅对“将要插入替换模板的捕获内容”做剪除。
- 剪除使用 `String.prototype.replaceAll`，不是正则。
- 每一条 trimString 也会先做宏替换（并允许指定 `name2Override`）。

对应实现：

```js
function filterString(rawString, trimStrings, { characterOverride } = {}) {
    let finalString = rawString;
    trimStrings.forEach((trimString) => {
        const subTrimString = substituteParams(trimString, { name2Override: characterOverride });
        finalString = finalString.replaceAll(subTrimString, '');
    });

    return finalString;
}
```

常见误解：很多人会把 Trim Out 当成“对整条消息执行”，导致和酒馆不一致。

---

## 8. 宏替换与“酒馆专属规则”

酒馆的“正则脚本”并不引入独立的正则语法；它的“专属能力”主要来自宏系统：

1) Find Regex 可选先做宏替换（`substituteRegex`）：

```js
export const substitute_find_regex = {
    NONE: 0,
    RAW: 1,
    ESCAPED: 2,
};
```

2) ESCAPED 模式会对宏值做“正则安全转义”（包括把控制字符映射为 `\n/\r/...`）：

```js
function sanitizeRegexMacro(x) {
    return (x && typeof x === 'string') ?
        x.replaceAll(/[\n\r\t\v\f\0.^$*+?{}[\]\\/|()]/gs, function (s) {
            switch (s) {
                case '\n':
                    return '\\n';
                case '\r':
                    return '\\r';
                case '\t':
                    return '\\t';
                case '\v':
                    return '\\v';
                case '\f':
                    return '\\f';
                case '\0':
                    return '\\0';
                default:
                    return '\\' + s;
            }
        }) : x;
}
```

3) Replace String 在捕获组处理后，会对**最终替换结果**再跑一遍宏替换：

```js
return substituteParams(replaceWithGroups);
```

这意味着：即使你的 `$1` 捕获内容里带 `{{...}}`，也可能在最后一步被宏系统继续展开。

### 8.1 宏系统的执行顺序（Legacy 引擎）

宏引擎有两套（实验性与 legacy）；正则脚本直接调用的是 `substituteParams(...)`（它会根据开关选择引擎）。这里展示 legacy 引擎中最关键的宏替换循环：

```js
export function evaluateMacros(content, env, postProcessFn) {
    if (!content) {
        return '';
    }

    postProcessFn = typeof postProcessFn === 'function' ? postProcessFn : (x => x);
    const rawContent = content;

    const preEnvMacros = [
        { regex: /<USER>/gi, replace: () => typeof env.user === 'function' ? env.user() : env.user },
        { regex: /<BOT>/gi, replace: () => typeof env.char === 'function' ? env.char() : env.char },
        { regex: /<CHAR>/gi, replace: () => typeof env.char === 'function' ? env.char() : env.char },
        { regex: /<CHARIFNOTGROUP>/gi, replace: () => typeof env.group === 'function' ? env.group() : env.group },
        { regex: /<GROUP>/gi, replace: () => typeof env.group === 'function' ? env.group() : env.group },
        { regex: /{{newline}}/gi, replace: () => '\n' },
        { regex: /(?:\r?\n)*{{trim}}(?:\r?\n)*/gi, replace: () => '' },
        { regex: /{{noop}}/gi, replace: () => '' },
        { regex: /{{input}}/gi, replace: () => String($('#send_textarea').val()) },
    ];

    const postEnvMacros = [
        { regex: /{{lastMessage}}/gi, replace: () => getLastMessage() },
        { regex: /{{time}}/gi, replace: () => moment().format('LT') },
        { regex: /{{date}}/gi, replace: () => moment().format('LL') },
        { regex: /{{weekday}}/gi, replace: () => moment().format('dddd') },
        { regex: /{{isotime}}/gi, replace: () => moment().format('HH:mm') },
        { regex: /{{isodate}}/gi, replace: () => moment().format('YYYY-MM-DD') },
        { regex: /{{datetimeformat +([^}]*)}}/gi, replace: (_, format) => moment().format(format) },
        { regex: /{{idle_duration}}/gi, replace: () => getTimeSinceLastMessage() },
        { regex: /{{reverse:(.+?)}}/gi, replace: (_, str) => Array.from(str).reverse().join('') },
        { regex: /\{\{\/\/([\s\S]*?)\}\}/gm, replace: () => '' },
    ];

    MacrosParser.populateEnv(env);
    const nonce = uuidv4();
    const envMacros = [];
    for (const varName in env) {
        if (!Object.hasOwn(env, varName)) continue;
        const envRegex = new RegExp(`{{${escapeRegex(varName)}}}`, 'gi');
        const envReplace = () => {
            const param = env[varName];
            const value = MacrosParser.sanitizeMacroValue(typeof param === 'function' ? param(nonce) : param);
            return value;
        };
        envMacros.push({ regex: envRegex, replace: envReplace });
    }

    const macros = [...preEnvMacros, ...envMacros, ...postEnvMacros];

    for (const macro of macros) {
        if (!content) {
            break;
        }
        if (!macro.regex.source.startsWith('<') && !content.includes('{{')) {
            break;
        }
        try {
            content = content.replace(macro.regex, (...args) => postProcessFn(macro.replace(...args)));
        } catch (e) {
            console.warn(`Macro content can't be replaced: ${macro.regex} in ${content}`, e);
        }
    }

    return content;
}
```

宏系统非常庞大；如果你只为“复刻正则输出”而不想引入宏，请在外部项目里明确：

- 是否要支持 `substituteRegex`（Find Regex 中的宏替换）。
- 是否要支持 Replace String 最后一轮的 `substituteParams`。

---

## 9. “AI 输出”在哪里被正则处理？（显示 vs 落盘）

### 9.1 显示渲染（markdownOnly）

消息渲染为 HTML 时，会在 markdown 转换前调用 `getRegexedString(..., { isMarkdown: true })`。这意味着：

- 这里**只会跑 markdownOnly 的脚本**。
- 渲染不会直接修改 `chat[].mes`（除特例：第 0 条消息有一段宏替换写回逻辑；与正则无关）。

对应片段（节选）：

```js
if (!isSystem) {
    function getRegexPlacement() {
        try {
            if (isReasoning) {
                return regex_placement.REASONING;
            }
            if (isUser) {
                return regex_placement.USER_INPUT;
            } else if (chat[messageId]?.extra?.type === 'narrator') {
                return regex_placement.SLASH_COMMAND;
            } else {
                return regex_placement.AI_OUTPUT;
            }
        } catch {
            return regex_placement.AI_OUTPUT;
        }
    }

    const regexPlacement = getRegexPlacement();
    const usableMessages = chat.map((x, index) => ({ message: x, index: index })).filter(x => !x.message.is_system);
    const indexOf = usableMessages.findIndex(x => x.index === Number(messageId));
    const depth = messageId >= 0 && indexOf !== -1 ? (usableMessages.length - indexOf - 1) : undefined;

    mes = getRegexedString(mes, regexPlacement, {
        characterOverride: ch_name,
        isMarkdown: true,
        depth: depth,
    });
}
```

### 9.2 持久化改写（两者都不是）

#### (1) AI 输出接收时：cleanUpMessage

AI 回复在进入后续清理之前，会调用：

```js
// Regex uses vars, so add before formatting
getMessage = getRegexedString(getMessage, isImpersonate ? regex_placement.USER_INPUT : regex_placement.AI_OUTPUT);
```

注意这里没有传 `isMarkdown/isPrompt`，因此会进入 **持久化改写模式**（只跑 `markdownOnly=false && promptOnly=false` 的脚本）。该返回值随后会被写入 `chat` 并保存。

#### (2) 用户消息发送时：sendMessageAsUser

用户输入同理：

```js
export async function sendMessageAsUser(messageText, messageBias, insertAt = null, compact = false, name = name1, avatar = user_avatar) {
    messageText = getRegexedString(messageText, regex_placement.USER_INPUT);

    const message = {
        name: name,
        is_user: true,
        is_system: false,
        send_date: getMessageTimeStamp(),
        mes: substituteParams(messageText),
        extra: {
            isSmallSys: compact,
        },
    };

    // ... push chat + saveChatConditional ...
}
```

#### (3) 编辑保存时：updateMessage + isEdit

编辑保存会传 `isEdit: true`，并只有在脚本 `runOnEdit=true` 时才会执行：

```js
let regexPlacement;
if (mes?.is_user) {
    regexPlacement = regex_placement.USER_INPUT;
} else if (mes.extra?.type === 'narrator') {
    regexPlacement = regex_placement.SLASH_COMMAND;
} else {
    regexPlacement = regex_placement.AI_OUTPUT;
}

text = getRegexedString(
    text,
    regexPlacement,
    {
        characterOverride: mes.extra?.type === 'narrator' ? undefined : mes.name,
        isEdit: true,
    },
);

// ... substituteParams(text) ...
mes['mes'] = text;
chat_metadata['tainted'] = true;
```

---

## 10. 深度（minDepth/maxDepth）到底怎么算？

深度 `depth` 是一个“从当前往回数”的索引：

- `0` 表示最后一条可用消息
- `1` 表示倒数第二条
- 以此类推

显示渲染阶段的深度：只统计 `!is_system` 的消息。

```js
const usableMessages = chat.map((x, index) => ({ message: x, index: index })).filter(x => !x.message.is_system);
const indexOf = usableMessages.findIndex(x => x.index === Number(messageId));
const depth = messageId >= 0 && indexOf !== -1 ? (usableMessages.length - indexOf - 1) : undefined;
```

构建 prompt 阶段的深度：按 prompt 使用的核心聊天列表计算（实现里是 `coreChat` 相对位置），并且在 continue 时会有一个偏移（`isContinue ? 2 : 1`）。

你在外部项目里复刻时，只要能稳定给出“从尾到头的距离”，即可与酒馆一致。

---

## 11. JSONL 导入/导出：服务端不会跑正则

你在外部项目里读到的 `.jsonl` 文件内容，服务端导出时不会额外应用正则。

### 11.1 JSONL 导出（原样返回）

```js
if (request.body.format === 'jsonl') {
    const rawFile = fs.readFileSync(filename, 'utf8');
    const successMessage = {
        message: `Chat saved to ${exportfilename}`,
        result: rawFile,
    };
    return response.status(200).json(successMessage);
}
```

### 11.2 JSONL 导入（仅做结构兼容，不跑正则）

导入时对 Chub 格式做“平坦化”（把 `{ mes: { message: ... } }` 变成 `{ mes: ... }`，并把 swipe 也拉平）：

```js
function flattenChubChat(userName, characterName, lines) {
    function flattenSwipe(swipe) {
        return swipe.message ? swipe.message : swipe;
    }

    function convert(line) {
        const lineData = tryParse(line);
        if (!lineData) return line;

        if (lineData.mes && lineData.mes.message) {
            lineData.mes = lineData?.mes.message;
        }

        if (lineData?.swipes && Array.isArray(lineData.swipes)) {
            lineData.swipes = lineData.swipes.map(swipe => flattenSwipe(swipe));
        }

        return JSON.stringify(lineData);
    }

    return (lines ?? []).map(convert).join('\n');
}
```

结论：正则脚本是浏览器端行为；JSONL 里之所以可能“已经被正则改过”，是因为持久化脚本在生成/编辑时就写回并保存了。

---

## 12. 复刻实现建议（读 JSONL 的外部项目）

### 12.1 你必须复刻的最小集合

如果你的目标是“读酒馆导出的 JSONL，并得到和酒馆一样的最终文本”，建议优先实现：

1) `regexFromString`：包括 flags 校验失败时的 `RegExp(input)` 回退行为。
2) 规则链筛选与三模式判定：`markdownOnly/promptOnly` 与 `isMarkdown/isPrompt` 的组合。
3) `runRegexScript`：`{{match}} -> $0`，`$n/$<name>` 处理，`trimStrings` 仅作用于捕获组，最后再跑宏（如果你需要宏）。

### 12.2 外部复刻伪代码

```ts
type RegexScript = {
  id: string
  scriptName: string
  findRegex: string
  replaceString: string
  trimStrings: string[]
  placement: number[]
  disabled?: boolean
  markdownOnly?: boolean
  promptOnly?: boolean
  runOnEdit?: boolean
  substituteRegex?: 0|1|2
  minDepth?: number|null
  maxDepth?: number|null
}

type RegexParams = {
  isMarkdown?: boolean
  isPrompt?: boolean
  isEdit?: boolean
  depth?: number
  characterOverride?: string
}

function getRegexedString(raw: string, placement: number, scripts: RegexScript[], params: RegexParams): string {
  if (typeof raw !== 'string') return ''
  if (!raw) return raw

  let out = raw
  for (const script of scripts) {
    if (script.disabled) continue
    if (!script.findRegex) continue
    if (!script.placement?.includes(placement)) continue

    const isMarkdown = !!params.isMarkdown
    const isPrompt = !!params.isPrompt
    const shouldRun =
      (script.markdownOnly && isMarkdown) ||
      (script.promptOnly && isPrompt) ||
      (!script.markdownOnly && !script.promptOnly && !isMarkdown && !isPrompt)
    if (!shouldRun) continue

    if (params.isEdit && !script.runOnEdit) continue

    if (typeof params.depth === 'number') {
      if (script.minDepth != null && !Number.isNaN(script.minDepth) && script.minDepth >= -1 && params.depth < script.minDepth) continue
      if (script.maxDepth != null && !Number.isNaN(script.maxDepth) && script.maxDepth >= 0 && params.depth > script.maxDepth) continue
    }

    out = runRegexScript(script, out, params)
  }
  return out
}
```

宏系统在酒馆里非常复杂；如果你只为“正则替换”而来，建议把宏作为可插拔层：

- `substituteParamsExtended(...)`：用于 Find Regex 的宏替换（RAW/ESCAPED）。
- `substituteParams(...)`：用于替换结果的最终宏替换，以及 trimStrings 的宏替换。

如果你的外部项目无法提供酒馆宏上下文（lastMessage、变量、时间等），那么即使正则逻辑完全一致，输出也会和酒馆不同——这不是正则的问题，而是宏环境不同。

---

## 13. 常见坑（你现在“总出问题”的高概率原因）

1) `findRegex` 的解析不一致
   - 你把 `"/blue/gi"` 当成普通字符串或错误地剥离 `/.../`。
   - 你没复刻 flags 校验失败的回退：酒馆会 `RegExp(input)`（导致完全不同的 pattern）。

2) `g` 语义不一致
   - 酒馆用的是 `String.prototype.replace(regex, fn)`：没有 `g` 就只替换第一处。

3) `trimStrings` 作用范围搞错
   - 酒馆只对捕获组内容 trim，不对整条消息 trim。
   - trim 是字符串 `replaceAll`，不是正则。

4) 宏替换未复刻或顺序不同
   - 酒馆会在捕获组注入后对最终替换结果再跑一遍宏替换。
   - Find Regex 也可能先跑宏替换（RAW/ESCAPED），并且 ESCAPED 会把换行等变成 `\n`。

5) “显示效果”和“JSONL 落盘内容”混用
   - 你在离线处理时把 `markdownOnly` 脚本也应用到了 JSONL 的持久化内容（酒馆不会）。
   - 或者你只跑了 display-only，没跑持久化脚本，导致与 JSONL 内容不一致。

---

## 14. 外部参考（官方说明与公开样例）

- 官方文档（Regex 扩展）：https://docs.sillytavern.app/extensions/regex/

公开样例（Regex Script JSON）里常见的写法包括：

- `"/<<<\\[TOOL_REQUEST\\]>>>[\\s\\S]*?「始」/g"` 这类跨行 + `g`
- `"/^(.*)$/s"` 这类 dotAll
- `"/!\\[[^\\]]*\\]\\( ... \\)/gs"` 这类复杂 Markdown 清理

这些样例可帮助你验证自己复刻的 `regexFromString`、JSON 转义与 flags 处理是否一致。
